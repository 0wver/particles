<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Particle Cloud - 1M Particle Option</title>
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #000000; /* Pure black background */
            color: #fff;
            overflow: hidden;
            cursor: default; 
            outline: none; 
            -webkit-user-select: none; 
            -ms-user-select: none; 
            user-select: none; 
        }
        #canvasContainer { 
            width: 100vw;
            height: 100vh;
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 0;
        }
        #controls {
            position: absolute;
            top: 15px;
            left: 15px;
            background-color: rgba(25, 25, 25, 0.92); 
            padding: 20px;
            padding-top: 40px; 
            border-radius: 12px; 
            box-shadow: 0 6px 25px rgba(0,0,0,0.5);
            display: flex;
            flex-direction: column;
            gap: 18px; 
            max-width: 340px; 
            max-height: calc(100vh - 40px); 
            overflow-y: auto;
            z-index: 10; 
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.5s ease-in-out, opacity 0.5s ease-in-out;
            transform: translateX(0);
            opacity: 1;
        }
        #controls.hidden {
            transform: translateX(-120%); 
            opacity: 0;
            pointer-events: none;
        }
        /* Close Button Style */
        #closeControlsButton {
            position: absolute;
            top: 10px;
            right: 10px;
            background: none;
            border: none;
            color: #aaa;
            font-size: 24px; 
            line-height: 1;
            padding: 5px;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        #closeControlsButton:hover {
            color: #fff;
        }

        #controls .control-group {
            border-bottom: 1px solid rgba(255,255,255,0.08);
            padding-bottom: 15px; 
        }
        #controls .control-group:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        #controls .control-group label,
        #controls .control-group .group-title {
            display: block;
            margin-bottom: 10px; 
            font-weight: 600;
            font-size: 0.95em; 
            color: #e8e8e8;
        }
         #controls .control-group .color-picker-label {
            font-size: 0.8em;
            color: #ccc;
            margin-bottom: 4px;
            display: block;
        }
        #controls .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px; 
            align-items: center;
        }
        #controls button {
            padding: 8px 12px; 
            background-color: #383838; 
            color: #e0e0e0;
            border: 1px solid #505050;
            border-radius: 8px; 
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease, border-color 0.2s ease;
            font-size: 0.85em; 
        }
        #controls button:hover {
            background-color: #007bff; 
            border-color: #007bff;
            color: white;
        }
        #controls button.active-toggle { 
            background-color: #007bff;
            border-color: #0056b3;
            color: white;
        }
        #controls button:active {
            transform: scale(0.95);
        }
        #controls input[type="color"] {
            width: 35px; 
            height: 28px;
            padding: 0;
            border: 1px solid #505050;
            border-radius: 6px;
            cursor: pointer;
            background: none;
            margin-right: 5px; 
        }
        #controls input[type="color"]::-webkit-color-swatch-wrapper { padding: 2px; }
        #controls input[type="color"]::-webkit-color-swatch { border: none; border-radius: 4px; }
        #controls input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: #007bff; 
        }
        #controls .slider-label-value {
            font-size: 0.8em; 
            color: #c0c0c0;
            margin-left: 8px;
        }
        #uiToggleHint {
            position: fixed;
            bottom: 20px; 
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 15px;
            background-color: rgba(25, 25, 25, 0.85);
            color: #c0c0c0;
            border-radius: 8px;
            font-size: 0.9em;
            z-index: 5; 
            transition: opacity 0.5s ease-in-out;
            opacity: 1;
            text-align: center; 
        }
        #uiToggleHint.hidden {
            opacity: 0;
            pointer-events: none;
        }
        #controls::-webkit-scrollbar { width: 8px; }
        #controls::-webkit-scrollbar-track { background: rgba(255,255,255,0.05); border-radius: 10px; }
        #controls::-webkit-scrollbar-thumb { background: #007bff; border-radius: 10px; }
        #controls::-webkit-scrollbar-thumb:hover { background: #0056b3; }

        /* Media Query for Mobile */
        @media (max-width: 600px) {
            #controls {
                max-width: 280px; 
                padding: 15px; 
                padding-top: 35px; 
                gap: 15px; 
                top: 10px;
                left: 10px;
                max-height: calc(100vh - 20px); 
            }
            #closeControlsButton {
                top: 8px;
                right: 8px;
                font-size: 22px;
            }
            #controls .control-group label,
            #controls .control-group .group-title {
                 font-size: 0.9em; 
                 margin-bottom: 10px;
            }
            #controls button {
                padding: 8px 10px; 
                font-size: 0.8em; 
            }
             #controls .button-group {
                 gap: 8px; 
             }
            #controls input[type="color"] {
                width: 35px; 
                height: 28px;
            }
             #uiToggleHint {
                 font-size: 0.8em; 
                 bottom: 10px;
                 width: calc(100% - 40px); 
             }
        }
    </style>
</head>
<body>
    <div id="canvasContainer"></div> 
    <div id="uiToggleHint">Press 'F', Double-Tap, or use 'X' to toggle UI</div> 
    <div id="controls">
        <button id="closeControlsButton" aria-label="Close Controls">&times;</button> 
        <div class="control-group">
            <label>Shape:</label>
            <div class="button-group">
                <button data-shape="sphere">Sphere</button>
                <button data-shape="cube">Cube</button>
                <button data-shape="torus">Torus</button>
                <button data-shape="cone">Cone</button>
                <button data-shape="cylinder">Cylinder</button>
                <button data-shape="spiral">Spiral</button>
                <button data-shape="pyramid">Pyramid</button> 
                <button data-shape="octahedron">Octahedron</button> 
                <button data-shape="cloud">Cloud</button>
            </div>
        </div>

        <div class="control-group">
            <label class="group-title">Particle Color</label>
            <label for="singleParticleColor" class="color-picker-label">Uniform Color:</label>
            <div class="button-group">
                <input type="color" id="singleParticleColor" value="#ffffff">
                <button id="applyUniformColor">Apply Uniform</button>
            </div>
            <label class="color-picker-label" style="margin-top:10px;">Gradient Colors:</label>
            <div class="button-group" style="flex-direction: column; align-items: flex-start; gap: 6px;">
                <div>
                    <label for="gradientColorBottom" class="color-picker-label" style="font-size:0.75em">Bottom:</label>
                    <input type="color" id="gradientColorBottom" value="#6a0dad">
                </div>
                <div>
                    <label for="gradientColorMiddle" class="color-picker-label" style="font-size:0.75em">Middle:</label>
                    <input type="color" id="gradientColorMiddle" value="#007bff">
                </div>
                <div>
                    <label for="gradientColorTop" class="color-picker-label" style="font-size:0.75em">Top:</label>
                    <input type="color" id="gradientColorTop" value="#00ffff">
                </div>
                <button id="applyGradientColors" style="margin-top: 5px;">Apply Gradient</button>
            </div>
            <label class="color-picker-label" style="margin-top:10px;">Special Modes:</label>
            <div class="button-group">
                <button id="randomColors">Random</button>
                <button id="rgbCycleColors">RGB Cycle</button>
                <button id="randomGradientCycle">Rand. Gradient Cycle</button> </div>
            <label for="rgbCycleSpeed" style="margin-top:10px;">RGB Cycle Speed <span id="rgbCycleSpeedLabel" class="slider-label-value">(0.5)</span>:</label>
            <input type="range" id="rgbCycleSpeed" min="0.05" max="2.0" value="0.5" step="0.05">
            <label for="gradientCycleInterval" style="margin-top:10px;">Gradient Cycle Interval <span id="gradientCycleIntervalLabel" class="slider-label-value">(3.0s)</span>:</label> <input type="range" id="gradientCycleInterval" min="1.0" max="10.0" value="3.0" step="0.5">
        </div>
        
        <div class="control-group">
            <label class="group-title">Automation</label>
            <button id="toggleAutoShapeTransition">Start Auto Shapes</button>
            <label for="autoTransitionInterval" style="margin-top:10px;">Auto Transition Interval <span id="autoTransitionIntervalLabel" class="slider-label-value">(5.0s)</span>:</label>
            <input type="range" id="autoTransitionInterval" min="2" max="15" value="5" step="0.5">
        </div>

        <div class="control-group">
            <label for="particleCount">Particle Count <span id="particleCountLabel" class="slider-label-value">(5,000)</span>:</label>
            <input type="range" id="particleCount" min="1000" max="1000000" value="5000" step="10000"> 
        </div>
        <div class="control-group">
            <label for="particleSize">Particle Size <span id="particleSizeLabel" class="slider-label-value">(1.0)</span>:</label>
            <input type="range" id="particleSize" min="0.1" max="5" value="1.0" step="0.1">
        </div>
        <div class="control-group">
            <label for="rotationSpeed">Shape Rotation Speed <span id="rotationSpeedLabel" class="slider-label-value">(0.5)</span>:</label> 
            <input type="range" id="rotationSpeed" min="0" max="5" value="0.5" step="0.05">
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer, particles, orbitControls;
        let particleMaterial, particleGeometry;

        // State variables
        let currentShapeType = 'sphere';
        let currentParticleColor = '#ffffff'; // Can be hex, 'random', 'gradient', 'rgbCycle', 'randomGradient'
        let currentParticleSize = 1.0;
        let currentParticleCount = 5000;
        let currentRotationSpeed = 0.5;
        let currentRgbCycleSpeed = 0.5; 
        let controlsVisible = true;

        // Auto-transition state
        let autoShapeTransitionActive = false;
        let autoShapeIntervalId = null;
        let currentAutoShapeInterval = 5000; 
        const SHAPE_SEQUENCE = ['sphere', 'cube', 'torus', 'cone', 'cylinder', 'spiral', 'pyramid', 'octahedron', 'cloud'];
        let currentShapeIndex = 0;

        // Random Gradient Cycle state
        let randomGradientIntervalId = null;
        let currentRandomGradientInterval = 3000; // ms (matches default slider value)


        // Gradient colors
        let GRADIENT_COLOR_BOTTOM = new THREE.Color(0x6a0dad);
        let GRADIENT_COLOR_MIDDLE = new THREE.Color(0x007bff); 
        let GRADIENT_COLOR_TOP = new THREE.Color(0x00ffff);


        // DOM Elements
        const canvasContainer = document.getElementById('canvasContainer'); 
        const controlsPanel = document.getElementById('controls');
        const uiToggleHint = document.getElementById('uiToggleHint'); 
        const closeControlsButton = document.getElementById('closeControlsButton'); 

        const singleParticleColorInput = document.getElementById('singleParticleColor');
        const gradientColorBottomInput = document.getElementById('gradientColorBottom');
        const gradientColorMiddleInput = document.getElementById('gradientColorMiddle');
        const gradientColorTopInput = document.getElementById('gradientColorTop');

        const particleCountInput = document.getElementById('particleCount');
        const particleSizeInput = document.getElementById('particleSize');
        const rotationSpeedInput = document.getElementById('rotationSpeed');
        const rgbCycleSpeedInput = document.getElementById('rgbCycleSpeed'); 
        const gradientCycleIntervalInput = document.getElementById('gradientCycleInterval'); 
        
        const toggleAutoShapeTransitionButton = document.getElementById('toggleAutoShapeTransition');
        const autoTransitionIntervalInput = document.getElementById('autoTransitionInterval');
        const autoTransitionIntervalLabel = document.getElementById('autoTransitionIntervalLabel');


        const particleCountLabel = document.getElementById('particleCountLabel');
        const particleSizeLabel = document.getElementById('particleSizeLabel');
        const rotationSpeedLabel = document.getElementById('rotationSpeedLabel');
        const rgbCycleSpeedLabel = document.getElementById('rgbCycleSpeedLabel'); 
        const gradientCycleIntervalLabel = document.getElementById('gradientCycleIntervalLabel'); 

        // Shape parameters
        const SHAPE_PARAMS = {
            sphere: { radius: 80 },
            cube: { size: 120 },
            torus: { radius: 70, tubeRadius: 25 },
            cone: { radius: 60, height: 100 },
            cylinder: { radiusTop: 40, radiusBottom: 40, height: 120 },
            spiral: { coils: 5, radius: 60, height: 100, pointsPerCoil: 200 },
            pyramid: { baseSize: 100, height: 100 }, 
            octahedron: { radius: 70 }, 
            cloud: { range: 150 }
        };

        // Double Tap Detection Variables
        let lastTap = 0;
        let touchStartX = 0;
        let touchStartY = 0;
        const doubleTapDelay = 300; // ms
        const tapMoveThreshold = 10; // pixels - ignore taps if finger moved too much

        // --- Initialization ---
        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 200; camera.lookAt(scene.position);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000); // Set pure black background
            canvasContainer.appendChild(renderer.domElement); 

            orbitControls = new THREE.OrbitControls(camera, renderer.domElement); 
            orbitControls.enableDamping = true; 
            orbitControls.dampingFactor = 0.05;
            orbitControls.minDistance = 10; 
            orbitControls.maxDistance = 1000; 
            
            GRADIENT_COLOR_BOTTOM.set(gradientColorBottomInput.value);
            GRADIENT_COLOR_MIDDLE.set(gradientColorMiddleInput.value);
            GRADIENT_COLOR_TOP.set(gradientColorTopInput.value);
            currentAutoShapeInterval = parseFloat(autoTransitionIntervalInput.value) * 1000;
            currentRandomGradientInterval = parseFloat(gradientCycleIntervalInput.value) * 1000;


            createParticles(currentParticleCount, currentShapeType, currentParticleColor, currentParticleSize);
            setupEventListeners();
            animate();
            
            if (controlsVisible) {
                 document.body.style.cursor = 'default';
                 uiToggleHint.classList.remove('hidden');
            } else {
                 document.body.style.cursor = 'none';
                 uiToggleHint.classList.add('hidden');
                 controlsPanel.classList.add('hidden'); 
            }
            document.body.focus(); 
        }

        // --- Particle Creation ---
        function createParticles(numParticles, shapeType, colorMode, sizeValue) {
            if (particles) {
                scene.remove(particles);
                if (particleGeometry) particleGeometry.dispose();
                if (particleMaterial) particleMaterial.dispose();
            }

            particleGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(numParticles * 3);
            const colors = new Float32Array(numParticles * 3);
            
            // Generate positions first
            for (let i = 0; i < numParticles; i++) {
                const pos = getPositionForShape(shapeType, i, numParticles);
                 // *** Error Handling Added Here ***
                if (pos && typeof pos.x !== 'undefined') {
                    positions[i * 3] = pos.x; 
                    positions[i * 3 + 1] = pos.y;
                    positions[i * 3 + 2] = pos.z;
                } else {
                    console.error(`getPositionForShape returned invalid value for shape "${shapeType}" at index ${i}`);
                    positions[i * 3] = 0; // Default position
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = 0;
                }
            }

            // Apply colors based on mode
            applyColorMode(colorMode, numParticles, positions, colors);


            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleMaterial = new THREE.PointsMaterial({
                size: sizeValue, vertexColors: true, sizeAttenuation: true,
                transparent: true, opacity: 0.85, depthWrite: false
            });
            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            currentParticleCount = numParticles; 
            currentParticleSize = sizeValue;
        }
        
        // Helper function to apply colors during creation or update
        function applyColorMode(colorMode, numParticles, positions, colorsArray) {
             const tempColor = new THREE.Color();
             if (colorMode === 'gradient' || colorMode === 'randomGradient') { 
                let minY = Infinity, maxY = -Infinity;
                for (let i = 0; i < numParticles; i++) {
                    const y = positions[i * 3 + 1];
                    if (y < minY) minY = y;
                    if (y > maxY) maxY = y;
                }
                for (let i = 0; i < numParticles; i++) {
                    const y = positions[i * 3 + 1];
                    const normalizedY = (maxY === minY) ? 0.5 : (y - minY) / (maxY - minY); 
                    if (normalizedY < 0.5) { 
                        tempColor.copy(GRADIENT_COLOR_BOTTOM).lerp(GRADIENT_COLOR_MIDDLE, normalizedY * 2);
                    } else { 
                        tempColor.copy(GRADIENT_COLOR_MIDDLE).lerp(GRADIENT_COLOR_TOP, (normalizedY - 0.5) * 2);
                    }
                    colorsArray[i * 3] = tempColor.r;
                    colorsArray[i * 3 + 1] = tempColor.g;
                    colorsArray[i * 3 + 2] = tempColor.b;
                }
            } else if (colorMode === 'random') {
                for (let i = 0; i < numParticles; i++) {
                    tempColor.setHex(Math.random() * 0xffffff);
                    colorsArray[i * 3] = tempColor.r;
                    colorsArray[i * 3 + 1] = tempColor.g;
                    colorsArray[i * 3 + 2] = tempColor.b;
                }
            } else if (colorMode === 'rgbCycle') {
                tempColor.setHSL(0, 1.0, 0.5); // Initial: Red
                 for (let i = 0; i < numParticles; i++) {
                    colorsArray[i * 3] = tempColor.r;
                    colorsArray[i * 3 + 1] = tempColor.g;
                    colorsArray[i * 3 + 2] = tempColor.b;
                }
            } else { // Specific uniform color
                tempColor.set(colorMode);
                for (let i = 0; i < numParticles; i++) {
                    colorsArray[i * 3] = tempColor.r;
                    colorsArray[i * 3 + 1] = tempColor.g;
                    colorsArray[i * 3 + 2] = tempColor.b;
                }
            }
        }


        // --- Shape Position Generators --- (Functions are unchanged)
        function getPositionForShape(shapeType, index, totalParticles) { 
            switch (shapeType) {
                case 'sphere':   return getSpherePosition(SHAPE_PARAMS.sphere.radius);
                case 'cube':     return getCubePosition(SHAPE_PARAMS.cube.size);
                case 'torus':    return getTorusPosition(SHAPE_PARAMS.torus.radius, SHAPE_PARAMS.torus.tubeRadius);
                case 'cone':     return getConePosition(SHAPE_PARAMS.cone.radius, SHAPE_PARAMS.cone.height);
                case 'cylinder': return getCylinderPosition(SHAPE_PARAMS.cylinder.radiusTop, SHAPE_PARAMS.cylinder.radiusBottom, SHAPE_PARAMS.cylinder.height);
                case 'spiral':   return getSpiralPosition(SHAPE_PARAMS.spiral.coils, SHAPE_PARAMS.spiral.radius, SHAPE_PARAMS.spiral.height, index, totalParticles);
                case 'pyramid':  return getPyramidPosition(SHAPE_PARAMS.pyramid.baseSize, SHAPE_PARAMS.pyramid.height); 
                case 'octahedron': return getOctahedronPosition(SHAPE_PARAMS.octahedron.radius); 
                case 'cloud': default: return getRandomCloudPosition(SHAPE_PARAMS.cloud.range);
            }
        }
        function getSpherePosition(radius) {
            const u = Math.random(), v = Math.random();
            const theta = 2 * Math.PI * u, phi = Math.acos(2 * v - 1);
            return new THREE.Vector3(radius * Math.sin(phi) * Math.cos(theta), radius * Math.sin(phi) * Math.sin(theta), radius * Math.cos(phi));
        }
        function getCubePosition(size) {
            return new THREE.Vector3((Math.random() - 0.5) * size, (Math.random() - 0.5) * size, (Math.random() - 0.5) * size);
        }
        function getTorusPosition(R, r) {
            const theta = Math.random() * 2 * Math.PI, phi = Math.random() * 2 * Math.PI;
            return new THREE.Vector3((R + r * Math.cos(phi)) * Math.cos(theta), (R + r * Math.cos(phi)) * Math.sin(theta), r * Math.sin(phi));
        }
        function getRandomCloudPosition(range) {
            return new THREE.Vector3((Math.random() - 0.5) * range, (Math.random() - 0.5) * range, (Math.random() - 0.5) * range);
        }
        function getConePosition(radius, height) {
            const u = Math.random(); 
            const theta = Math.random() * 2 * Math.PI; 
            const h = u * height; 
            const r = radius * (1 - u); 
            const x = r * Math.cos(theta);
            const y = h - height / 2; 
            const z = r * Math.sin(theta);
            return new THREE.Vector3(x, y, z);
        }
        function getCylinderPosition(radiusTop, radiusBottom, height) {
            const u = Math.random(); 
            const theta = Math.random() * 2 * Math.PI; 
            const h = u * height; 
            const r = radiusBottom + (radiusTop - radiusBottom) * u;
            const x = r * Math.cos(theta);
            const y = h - height / 2; 
            const z = r * Math.sin(theta);
            return new THREE.Vector3(x, y, z);
        }
        function getSpiralPosition(coils, radius, height, index, totalParticles) {
            const t = index / (totalParticles -1); 
            const angle = coils * 2 * Math.PI * t; 
            const currentRadius = radius * t; 
            const x = currentRadius * Math.cos(angle);
            const y = (t - 0.5) * height; 
            const z = currentRadius * Math.sin(angle);
            return new THREE.Vector3(x, y, z);
        }
        function getPyramidPosition(baseSize, height) {
            const halfBase = baseSize / 2;
            let x, y, z;
            const baseX = (Math.random() - 0.5) * baseSize;
            const baseZ = (Math.random() - 0.5) * baseSize;
            const isBasePoint = Math.random() < 0.2; 

            if (isBasePoint) {
                x = baseX;
                y = -height / 2;
                z = baseZ;
            } else {
                const apexY = height / 2;
                const lerpFactor = Math.random(); 
                x = baseX * (1 - lerpFactor);
                y = -height/2 * (1-lerpFactor) + apexY * lerpFactor;
                z = baseZ * (1 - lerpFactor);
            }
            return new THREE.Vector3(x, y, z);
        }
        function getOctahedronPosition(radius) {
            let x, y, z;
            do {
                x = (Math.random() * 2 - 1); 
                y = (Math.random() * 2 - 1);
                z = (Math.random() * 2 - 1);
            } while (x === 0 && y === 0 && z === 0); 

            const d = Math.abs(x) + Math.abs(y) + Math.abs(z); 
            x = (x / d) * radius;
            y = (y / d) * radius;
            z = (z / d) * radius;
            
            return new THREE.Vector3(x, y, z);
        }


        // --- Animations ---
        function animateParticlesToShape(newShapeType, duration = 2000) {
            if (!particles || !particles.geometry) return; 
            currentShapeType = newShapeType; 

            const posAttr=particles.geometry.attributes.position;
            const currPos=new Float32Array(posAttr.array);
            const finalPosArr=posAttr.array;
            const numP = currentParticleCount; // Use state variable
            const targetPos=new Float32Array(numP*3);

            for(let i=0;i<numP;i++){
                const nP=getPositionForShape(newShapeType,i,numP);
                 // *** Error Handling Added Here ***
                if (nP && typeof nP.x !== 'undefined') {
                    targetPos[i*3]=nP.x;
                    targetPos[i*3+1]=nP.y;
                    targetPos[i*3+2]=nP.z;
                } else {
                     console.error(`getPositionForShape returned invalid value during animation for shape "${newShapeType}" at index ${i}`);
                     // Use current position as target to avoid sudden jump to origin
                     targetPos[i*3]=currPos[i*3];
                     targetPos[i*3+1]=currPos[i*3+1];
                     targetPos[i*3+2]=currPos[i*3+2];
                }
            }
            anime.remove(finalPosArr);
            anime({targets:{value:0},value:1,duration:duration,easing:'easeInOutExpo',
                update:(anim)=>{
                    const p=anim.progress/100;
                    for(let i=0;i<numP;i++){ // Use numP from outer scope
                        const id=i*3;
                        finalPosArr[id]=currPos[id]+(targetPos[id]-currPos[id])*p;
                        finalPosArr[id+1]=currPos[id+1]+(targetPos[id+1]-currPos[id+1])*p;
                        finalPosArr[id+2]=currPos[id+2]+(targetPos[id+2]-currPos[id+2])*p;
                    }
                    posAttr.needsUpdate=true; 
                },
                complete:()=>{
                    for(let i=0;i<numP;i++){ // Use numP from outer scope
                        const id=i*3;
                        finalPosArr[id]=targetPos[id];
                        finalPosArr[id+1]=targetPos[id+1];
                        finalPosArr[id+2]=targetPos[id+2];
                    }
                    posAttr.needsUpdate=true;
                    if (currentParticleColor === 'gradient' || currentParticleColor === 'randomGradient') {
                        animateParticleColors(currentParticleColor, 500); 
                    }
                }
            });
        }

        function animateParticleColors(newColorMode, duration = 1500) {
            if (!particles || !particles.geometry) return;

            if (newColorMode !== 'randomGradient' && randomGradientIntervalId) {
                stopRandomGradientCycle();
            }
           
            currentParticleColor = newColorMode; 

            const colorsAttribute = particles.geometry.attributes.color;
            const currentColors = new Float32Array(colorsAttribute.array);
            const finalColorsArray = colorsAttribute.array;
            const numParticles = currentParticleCount; // Use state variable
            // Ensure targetColors array is large enough
            const targetColors = new Float32Array(numParticles * 3); 
            const tempTargetColor = new THREE.Color();

            // --- Calculate Target Colors ---
            if (newColorMode === 'gradient' || newColorMode === 'randomGradient') { 
                 if (newColorMode === 'randomGradient') {
                    GRADIENT_COLOR_BOTTOM.setHex(Math.random() * 0xffffff);
                    GRADIENT_COLOR_MIDDLE.setHex(Math.random() * 0xffffff);
                    GRADIENT_COLOR_TOP.setHex(Math.random() * 0xffffff);
                    gradientColorBottomInput.value = '#' + GRADIENT_COLOR_BOTTOM.getHexString();
                    gradientColorMiddleInput.value = '#' + GRADIENT_COLOR_MIDDLE.getHexString();
                    gradientColorTopInput.value = '#' + GRADIENT_COLOR_TOP.getHexString();
                 } else {
                    GRADIENT_COLOR_BOTTOM.set(gradientColorBottomInput.value);
                    GRADIENT_COLOR_MIDDLE.set(gradientColorMiddleInput.value);
                    GRADIENT_COLOR_TOP.set(gradientColorTopInput.value);
                 }

                const positionsAttribute = particles.geometry.attributes.position;
                let minY = Infinity, maxY = -Infinity;
                for (let i = 0; i < numParticles; i++) {
                    const y = positionsAttribute.array[i * 3 + 1];
                    if (y < minY) minY = y; if (y > maxY) maxY = y;
                }
                for (let i = 0; i < numParticles; i++) {
                    const y = positionsAttribute.array[i * 3 + 1];
                    const normalizedY = (maxY === minY) ? 0.5 : (y - minY) / (maxY - minY);
                    if (normalizedY < 0.5) {
                        tempTargetColor.copy(GRADIENT_COLOR_BOTTOM).lerp(GRADIENT_COLOR_MIDDLE, normalizedY * 2);
                    } else {
                        tempTargetColor.copy(GRADIENT_COLOR_MIDDLE).lerp(GRADIENT_COLOR_TOP, (normalizedY - 0.5) * 2);
                    }
                    targetColors[i * 3]=tempTargetColor.r; targetColors[i*3+1]=tempTargetColor.g; targetColors[i*3+2]=tempTargetColor.b;
                }
            } else if (newColorMode === 'random') {
                for (let i = 0; i < numParticles; i++) {
                    tempTargetColor.setHex(Math.random() * 0xffffff);
                    targetColors[i*3]=tempTargetColor.r; targetColors[i*3+1]=tempTargetColor.g; targetColors[i*3+2]=tempTargetColor.b;
                }
            } else if (newColorMode === 'rgbCycle') {
                const time = Date.now() * 0.0005 * currentRgbCycleSpeed; 
                const hue = (time % 1);
                tempTargetColor.setHSL(hue, 1.0, 0.5);
                for (let i = 0; i < numParticles; i++) {
                    finalColorsArray[i*3]=tempTargetColor.r; finalColorsArray[i*3+1]=tempTargetColor.g; finalColorsArray[i*3+2]=tempTargetColor.b;
                }
                colorsAttribute.needsUpdate = true;
                return; 
            } else { // Specific uniform color
                tempTargetColor.set(newColorMode); 
                for (let i = 0; i < numParticles; i++) {
                    targetColors[i*3]=tempTargetColor.r; targetColors[i*3+1]=tempTargetColor.g; targetColors[i*3+2]=tempTargetColor.b;
                }
            }
            
            // --- Animate Colors (except for RGB cycle) ---
            anime.remove(finalColorsArray);
            anime({
                targets: { value: 0 }, value: 1, duration: duration, easing: 'easeInOutQuad',
                update: (anim)=>{
                    const p=anim.progress/100;
                    for(let i=0;i<numParticles;i++){
                        const id=i*3;
                        // Check array bounds just in case, though numParticles should be correct
                        if (id + 2 < finalColorsArray.length && id + 2 < currentColors.length && id + 2 < targetColors.length) {
                            finalColorsArray[id]=currentColors[id]+(targetColors[id]-currentColors[id])*p;
                            finalColorsArray[id+1]=currentColors[id+1]+(targetColors[id+1]-currentColors[id+1])*p;
                            finalColorsArray[id+2]=currentColors[id+2]+(targetColors[id+2]-currentColors[id+2])*p;
                        }
                    }
                    colorsAttribute.needsUpdate=true;
                },
                complete: ()=>{
                    for(let i=0;i<numParticles;i++){
                        const id=i*3;
                         if (id + 2 < finalColorsArray.length && id + 2 < targetColors.length) {
                            finalColorsArray[id]=targetColors[id];
                            finalColorsArray[id+1]=targetColors[id+1];
                            finalColorsArray[id+2]=targetColors[id+2];
                         }
                    }
                    colorsAttribute.needsUpdate=true;
                    if (newColorMode === 'randomGradient') {
                        startRandomGradientCycle();
                    }
                }
            });
        }


        // --- UI Toggling ---
        function toggleControls() {
            controlsVisible = !controlsVisible;
            if (controlsVisible) {
                controlsPanel.classList.remove('hidden');
                uiToggleHint.classList.remove('hidden'); 
                document.body.style.cursor = 'default';
            } else {
                controlsPanel.classList.add('hidden');
                uiToggleHint.classList.add('hidden'); 
                document.body.style.cursor = 'none';
                if (autoShapeTransitionActive) {
                    stopAutoShapeTransition();
                }
                if (currentParticleColor === 'randomGradient') {
                    stopRandomGradientCycle();
                }
            }
        }

        // --- Auto Shape Transition Logic ---
        function transitionToNextShape() {
            currentShapeIndex = (currentShapeIndex + 1) % SHAPE_SEQUENCE.length;
            const nextShape = SHAPE_SEQUENCE[currentShapeIndex];
            animateParticlesToShape(nextShape);
        }

        function startAutoShapeTransition() {
            if (autoShapeIntervalId) clearInterval(autoShapeIntervalId); 
            autoShapeTransitionActive = true;
            toggleAutoShapeTransitionButton.textContent = 'Stop Auto Shapes';
            toggleAutoShapeTransitionButton.classList.add('active-toggle');
            transitionToNextShape(); 
            autoShapeIntervalId = setInterval(transitionToNextShape, currentAutoShapeInterval);
        }

        function stopAutoShapeTransition() {
            autoShapeTransitionActive = false;
            if (autoShapeIntervalId) {
                clearInterval(autoShapeIntervalId);
                autoShapeIntervalId = null;
            }
            toggleAutoShapeTransitionButton.textContent = 'Start Auto Shapes';
            toggleAutoShapeTransitionButton.classList.remove('active-toggle');
        }

        function handleToggleAutoShapeTransition() {
            if (autoShapeTransitionActive) {
                stopAutoShapeTransition();
            } else {
                startAutoShapeTransition();
            }
        }

        // --- Random Gradient Cycle Logic ---
        function randomizeAndApplyGradient() {
             if (!particles || currentParticleColor !== 'randomGradient') {
                 stopRandomGradientCycle(); 
                 return;
             }
            GRADIENT_COLOR_BOTTOM.setHex(Math.random() * 0xffffff);
            GRADIENT_COLOR_MIDDLE.setHex(Math.random() * 0xffffff);
            GRADIENT_COLOR_TOP.setHex(Math.random() * 0xffffff);
            
            gradientColorBottomInput.value = '#' + GRADIENT_COLOR_BOTTOM.getHexString();
            gradientColorMiddleInput.value = '#' + GRADIENT_COLOR_MIDDLE.getHexString();
            gradientColorTopInput.value = '#' + GRADIENT_COLOR_TOP.getHexString();

            animateParticleColors('gradient', 1500); 
             currentParticleColor = 'randomGradient'; 
        }

         function startRandomGradientCycle() {
            stopRandomGradientCycle(); 
            currentParticleColor = 'randomGradient'; 
            randomizeAndApplyGradient(); 
            randomGradientIntervalId = setInterval(randomizeAndApplyGradient, currentRandomGradientInterval);
             document.getElementById('randomGradientCycle').classList.add('active-toggle');

        }

        function stopRandomGradientCycle() {
            if (randomGradientIntervalId) {
                clearInterval(randomGradientIntervalId);
                randomGradientIntervalId = null;
            }
            document.getElementById('randomGradientCycle').classList.remove('active-toggle');
        }


        // --- Event Listeners Setup ---
        function setupEventListeners() {
            // Keyboard shortcut for UI toggle
            window.addEventListener('keydown', (event) => {
                if (event.key.toLowerCase() === 'f' && !(event.target instanceof HTMLInputElement || event.target instanceof HTMLTextAreaElement)) {
                    toggleControls();
                }
            });

             // Touch listeners for Double Tap
            canvasContainer.addEventListener('touchstart', (event) => {
                if (event.touches.length === 1) {
                    touchStartX = event.touches[0].clientX;
                    touchStartY = event.touches[0].clientY;
                }
            }, { passive: true }); 

            canvasContainer.addEventListener('touchend', (event) => {
                if (event.changedTouches.length !== 1 || event.touches.length > 0) { 
                    lastTap = 0; 
                    return;
                }

                const touchEndX = event.changedTouches[0].clientX;
                const touchEndY = event.changedTouches[0].clientY;
                const deltaX = Math.abs(touchEndX - touchStartX);
                const deltaY = Math.abs(touchEndY - touchStartY);

                if (deltaX > tapMoveThreshold || deltaY > tapMoveThreshold) {
                    lastTap = 0; 
                    return;
                }
                
                const currentTime = new Date().getTime();
                const timeSinceLastTap = currentTime - lastTap;

                if (timeSinceLastTap < doubleTapDelay && timeSinceLastTap > 0) {
                    toggleControls();
                    event.preventDefault(); 
                    lastTap = 0; 
                } else {
                    lastTap = currentTime; 
                }
            }, { passive: false }); 
            
            canvasContainer.addEventListener('contextmenu', (event) => {
                event.preventDefault();
            });

            // Close button listener
            closeControlsButton.addEventListener('click', toggleControls);


            // Shape buttons
            document.querySelectorAll('#controls button[data-shape]').forEach(button => {
                button.addEventListener('click', () => {
                    if (autoShapeTransitionActive) stopAutoShapeTransition();
                    animateParticlesToShape(button.getAttribute('data-shape'));
                    const index = SHAPE_SEQUENCE.indexOf(button.getAttribute('data-shape'));
                    if (index !== -1) currentShapeIndex = index;
                });
            });

            // Color controls - Ensure cycles are stopped when changing modes
            document.getElementById('applyUniformColor').addEventListener('click', () => {
                 stopRandomGradientCycle(); 
                 animateParticleColors(singleParticleColorInput.value);
            });
            document.getElementById('randomColors').addEventListener('click', () => {
                 stopRandomGradientCycle();
                 animateParticleColors('random');
            });
            document.getElementById('applyGradientColors').addEventListener('click', () => {
                 stopRandomGradientCycle();
                 animateParticleColors('gradient');
            });
            document.getElementById('rgbCycleColors').addEventListener('click', () => {
                 stopRandomGradientCycle();
                 animateParticleColors('rgbCycle');
            });
             document.getElementById('randomGradientCycle').addEventListener('click', () => {
                 if (currentParticleColor === 'randomGradient' && randomGradientIntervalId) {
                     stopRandomGradientCycle();
                     animateParticleColors('gradient'); 
                 } else {
                     animateParticleColors('randomGradient'); 
                 }
            });
            
            gradientColorBottomInput.addEventListener('input', (e) => GRADIENT_COLOR_BOTTOM.set(e.target.value));
            gradientColorMiddleInput.addEventListener('input', (e) => GRADIENT_COLOR_MIDDLE.set(e.target.value));
            gradientColorTopInput.addEventListener('input', (e) => GRADIENT_COLOR_TOP.set(e.target.value));

            // Sliders
            particleCountInput.addEventListener('input', (event) => particleCountLabel.textContent = `(${parseInt(event.target.value).toLocaleString()})`); // Format large numbers
            particleCountInput.addEventListener('change', (event) => {
                const newCount = parseInt(event.target.value);
                currentParticleCount = newCount; 
                createParticles(newCount, currentShapeType, currentParticleColor, currentParticleSize);
            });
            particleSizeInput.addEventListener('input', (event) => {
                const size = parseFloat(event.target.value);
                particleSizeLabel.textContent = `(${size.toFixed(1)})`;
                if (particles && particles.material) { particles.material.size = size; currentParticleSize = size; }
            });
            rotationSpeedInput.addEventListener('input', (event) => {
                currentRotationSpeed = parseFloat(event.target.value);
                rotationSpeedLabel.textContent = `(${currentRotationSpeed.toFixed(2)})`;
            });
            rgbCycleSpeedInput.addEventListener('input', (event) => {
                currentRgbCycleSpeed = parseFloat(event.target.value);
                rgbCycleSpeedLabel.textContent = `(${currentRgbCycleSpeed.toFixed(2)})`;
            });
            // New Slider Listener
            gradientCycleIntervalInput.addEventListener('input', (event) => {
                const newIntervalSeconds = parseFloat(event.target.value);
                gradientCycleIntervalLabel.textContent = `(${newIntervalSeconds.toFixed(1)}s)`;
                currentRandomGradientInterval = newIntervalSeconds * 1000;
                if (currentParticleColor === 'randomGradient') { 
                    startRandomGradientCycle(); 
                }
            });


            // Automation controls
            toggleAutoShapeTransitionButton.addEventListener('click', handleToggleAutoShapeTransition);
            autoTransitionIntervalInput.addEventListener('input', (event) => {
                const newIntervalSeconds = parseFloat(event.target.value);
                autoTransitionIntervalLabel.textContent = `(${newIntervalSeconds.toFixed(1)}s)`;
                currentAutoShapeInterval = newIntervalSeconds * 1000;
                if (autoShapeTransitionActive) { 
                    startAutoShapeTransition(); 
                }
            });

            // Window resize
            window.addEventListener('resize', onWindowResize);
        }

        // --- Window Resize Handler ---
        function onWindowResize() { 
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
        }

        // --- Animation Loop ---
        function animate() { 
            requestAnimationFrame(animate);
            orbitControls.update(); 
            const time = Date.now();

            // Background is static black

            // RGB Cycle for particles if active
            if (currentParticleColor === 'rgbCycle' && particles && particles.geometry) {
                const particleHue = (time * 0.0005 * currentRgbCycleSpeed) % 1; 
                const cycleColor = new THREE.Color();
                cycleColor.setHSL(particleHue, 1.0, 0.5);

                const colorsAttribute = particles.geometry.attributes.color;
                const colorsArray = colorsAttribute.array;
                const r = cycleColor.r;
                const g = cycleColor.g;
                const b = cycleColor.b;
                // Use currentParticleCount from state for loop limit
                for (let i = 0; i < currentParticleCount; i++) { 
                    const idx = i * 3;
                     if (idx + 2 < colorsArray.length) { // Bounds check
                        colorsArray[idx]= r; 
                        colorsArray[idx + 1]= g; 
                        colorsArray[idx + 2]= b;
                     }
                }
                colorsAttribute.needsUpdate = true; 
            }

            // Particle system rotation
            if (particles) {
                 particles.rotation.y += 0.001 * currentRotationSpeed;
                 particles.rotation.x += 0.0004 * currentRotationSpeed;
            }
            renderer.render(scene, camera);
        }

        // --- Start ---
        init();
    </script>
</body>
</html>
